{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":1,"trackAxes":"xy","mouseMomentum":1,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uTime;\nuniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0.12549019607843137, 0.023529411764705882, 0.23137254901960785);\ncase 1: return vec3(0.4666666666666667, 0.09019607843137255, 0.40784313725490196);\ncase 2: return vec3(0, 0.023529411764705882, 0.050980392156862744);\ncase 3: return vec3(0.8274509803921568, 0.35294117647058826, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.3333;\ncase 2: return 0.6667;\ncase 3: return 1.0000;\ncase 4: return 0.0000;\ncase 5: return 0.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}float rand(vec2 co) {\nreturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(rgb, vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(lin, vec3(1.0/2.2));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) );\nvec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) );\nvec3 lms = mix( lms1, lms2, a );\nlms *= 1.0 + 0.025 * a * (1.0-a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nfor (int i = 0; i < 4 - 1; i++) {\nfloat colorPosition = getStop(i);\nfloat nextColorPosition = getStop(i + 1);\nif (position <= nextColorPosition) {\nfloat mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition);\nvec3 linStart = linear_from_srgb(getColor(i));\nvec3 linEnd = linear_from_srgb(getColor(i + 1));\nvec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor);\nreturn srgb_from_linear(mixedLin);\n}\n}\nreturn getColor(4 - 1);\n}out vec4 fragColor;vec3 applyColorToPosition(float position) {\nvec3 color = vec3(0);\nposition -= (uTime * 0.01 + 0.0000);\nfloat cycle = floor(position);\nbool reverse = 1.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos);\nfloat dither = rand(gl_FragCoord.xy) * 0.005;\ncolor += dither;\nreturn color;\n}vec3 linearGrad(vec2 uv) {\nfloat position = (uv.x+0.5);\nreturn applyColorToPosition(position);\n}vec3 getGradient(vec2 uv) {\nreturn linearGrad(uv);\n}vec3 getColor(vec2 uv) {return getGradient(uv);return vec3(0.12549019607843137, 0.023529411764705882, 0.23137254901960785);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.25,"trackMouse":1,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 drawStar(vec2 uv, vec2 center, float scale) {\nuv.x *= uResolution.x/uResolution.y;\ncenter.x *= uResolution.x/uResolution.y;vec3 total = vec3(0);for(float i = 0.; i < 3.; i++) {\nfloat angle = 0.0000 + i/3. + uTime * 0.01;\nfloat thickness = 0.5000 * 0.5;\nvec2 skew = vec2(0.5 + thickness, 0.5 - thickness) * 2.;\nvec2 st = uv * rot(angle * TWO_PI) * skew;\nvec2 c = center * rot(angle * TWO_PI) * skew;\nfloat dist = distance(st, c);\nfloat radius = scale * 0.25;vec3 brightness = (radius / dist) * vec3(0.25882352941176473, 0.1607843137254902, 0.9176470588235294);total += brightness * 0.3333;\n}return total;\n}vec3 getBeam(vec2 uv) {\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 1.0000);\nreturn drawStar(uv, pos, 0.5000);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 1.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, luma(beam)));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"swirl","usesPingPong":false,"speed":0.5,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;\nvoid main() {\nvec2 uv = vTextureCoord;\nfloat angle = 0.5000 * 10.;\nvec2 originalUV = uv;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);uv -= pos;\nvec2 R = vec2(uv.x * uResolution.x / uResolution.y, uv.y);\nfloat distanceToCenter = length(R);\ndistanceToCenter += 0.0000*0.5;\nif (distanceToCenter <= 0.5000) {\nfloat rot = atan(R.y, R.x) + angle * smoothstep(0.5000, 0., distanceToCenter);\nuv = vec2(cos(rot + uTime / 20. + 0.0000 * 6.28), sin(rot + uTime / 20. + 0.0000 * 6.28));\nuv = distanceToCenter * uv + pos;\n}\nfloat t = smoothstep(0., 0.5000, distanceToCenter);\nvec2 mixedUV = mix(uv, originalUV, t);vec4 color = texture(uTexture, mix(vTextureCoord, mixedUV, 1.0000));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sphere","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;const float STEPS = 16.0;\nconst float PI = 3.1415926;vec3 chromaticAbberation(vec2 st, float angle, float amount, float blend) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat rotation = angle * 360.0 * PI / 180.0;\nvec2 aberrated = amount * vec2(0.1 * sin(rotation) * aspectRatio, 0.1 * cos(rotation));\naberrated *= distance(st, vec2(0.5)) * 2.0;\nvec4 red = vec4(0);\nvec4 blue = vec4(0);\nvec4 green = vec4(0);\nfloat invSteps = 1.0 / STEPS;\nfloat invStepsHalf = invSteps * 0.5;\nfor(float i = 1.0; i <= STEPS; i++) {\nvec2 offset = aberrated * (i * invSteps);\nred += texture(uTexture, st - offset) * invSteps;\nblue += texture(uTexture, st + offset) * invSteps;\n}for (float i = 0.0; i <= STEPS; i++) {\nvec2 offset = aberrated * ((i * invSteps) - 0.5);\ngreen += texture(uTexture, st + offset) * invSteps;\n}\nreturn vec3(red.r, green.g, blue.b);\n}vec2 sphericalTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat tau) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nu -= uCenter;\nv -= vCenter;float s = sqrt(u * u + v * v);\nif (s > lensRadius)\nreturn vec2(u + uCenter, v + vCenter);float z = sqrt(lensRadius * lensRadius - s * s);float uAlpha = (1.0 - (1.0 / tau)) * asin(u / lensRadius);\nfloat vAlpha = (1.0 - (1.0 / tau)) * asin(v / lensRadius);u = uCenter + z * sin(uAlpha);\nv = vCenter + z * sin(vAlpha);return vec2(u/aspectRatio, v);\n}float circularIn(float t) {\nreturn 1.0 - sqrt(1.0 - t * t);\n}vec2 fisheyeTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat distortionScale\n) {\nfloat aspectRatio = uResolution.x / uResolution.y;vec2 dir = vec2(u - uCenter, v - vCenter);dir.x /= lensRadius;\ndir.y /= lensRadius;float dist = length(dir) * 0.15;if (dist < 1.0) {\nfloat theta = atan(dir.y, dir.x);float r = dist * 2.0 * PI;\nfloat z = sqrt(1.0 - r * r) + 0.25;\nfloat rDist = atan(r, z) / PI;\nfloat newDist = mix(dist, rDist, 5.);dir.x = newDist * cos(theta);\ndir.y = newDist * sin(theta);\n}dir.x *= lensRadius;\ndir.y *= lensRadius;return mix(vec2(u/aspectRatio, v), vec2(uCenter/aspectRatio, vCenter) + dir, 0.5000);\n}vec2 discTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat distortionScale) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nu -= uCenter;\nv -= vCenter;float s = sqrt(u * u + v * v);\nif (s > lensRadius)\nreturn vec2(u + uCenter, v + vCenter);\nfloat r = sqrt(u * u + v * v) / lensRadius;\nif(r == 0.0)\nreturn vec2(uCenter, vCenter);r = pow(r, distortionScale);\nfloat theta = atan(r);\nfloat rad = theta / r;u = rad * u + uCenter;\nv = rad * v + vCenter;return vec2(u/aspectRatio, v);\n}out vec4 fragColor;\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfloat aspectRatio = uResolution.x/uResolution.y;\nuv.x = uv.x * aspectRatio;\nvec2 sphereCoords = uv;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\npos.x *= aspectRatio;float radius = 2.7100 * uResolution.x/max(uResolution.x, uResolution.y);if(0 == 0) {\nsphereCoords = sphericalTransformation(\nmix(sphereCoords.x, 1.-sphereCoords.x, 0.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 0.0000),\nmix(pos.x, 1.-pos.x, 0.0000),\nmix(pos.y, 1.-pos.y, 0.0000),\nradius/2.,\n1. + 0.5000 * 9.\n);\n} else if(0 == 1) {\nsphereCoords = discTransformation(\nmix(sphereCoords.x, 1.-sphereCoords.x, 0.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 0.0000),\nmix(pos.x, 1.-pos.x, 0.0000),\nmix(pos.y, 1.-pos.y, 0.0000),\nradius/2.,\n1. + 0.5000 * 9.\n);\n} else if(0 == 2) {\nsphereCoords = fisheyeTransformation(\nmix(sphereCoords.x, 1.-sphereCoords.x, 0.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 0.0000),\nmix(pos.x, 1.-pos.x, 0.0000),\nmix(pos.y, 1.-pos.y, 0.0000),\nradius/2.,\n1. + 0.5000 * 9.\n);\n}vec2 scaledCoords = (sphereCoords - 0.5) + 0.5;\nvec4 sphere = texture(uTexture, clamp(scaledCoords, 0.0, 1.0));\nfloat distFromPos = distance(uv, pos);\nfloat edgeSmooth = 0.001;\nfloat insideSphere = 1.0 - smoothstep(radius/2.0 - edgeSmooth, radius/2.0, distFromPos);\nfloat insideSphereAlpha = 1.0 - smoothstep(radius/2.0 + 0.002 - edgeSmooth, radius/2.0 + 0.002, distFromPos);\nsphere.rgb = chromaticAbberation(scaledCoords, atan(scaledCoords.y, scaledCoords.x), distFromPos * 0.5000, 1.0);\ncolor = mix(color, sphere, insideSphere);\ncolor.rgb += vec3((0.5000-0.5)*2.) * mix(0., circularIn(smoothstep(0., radius, distFromPos)), insideSphere);\nif(0 == 1) {\ncolor.a = insideSphereAlpha;\ncolor.rgb = mix(vec3(0), color.rgb, insideSphereAlpha);\n}\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;out vec4 fragColor;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114));\nfloat displacement = (luma - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.5000, 1.0 - 0.5000);\nfloat halfRadius = 0.7300 * 0.5;\nfloat innerEdge = halfRadius - 1.0000 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 1.0000 * halfRadius * 0.5;\nvec2 pos = vec2(0.5, 0.5);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nvec3 finalColor;finalColor = mix(bg.rgb, mix(bg.rgb, vec3(0.0784313725490196, 0, 0.1568627450980392), 1.0000), falloff);float alpha = max(bg.a, falloff * 1.0000);\nvec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"godrays","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;vec4 getBrightAreas(vec2 uv) {\nvec4 color = texture(uTexture, uv);\nfloat lum = dot(color.rgb, vec3(0.299, 0.587, 0.114));\ncolor = color * smoothstep(0.5000 - 0.1, 0.5000, lum);\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getBrightAreas(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(0 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;vec4 godRays(vec2 st, float decay) {\nvec3 color = vec3(0);\nfloat offset = (0.25 + min(1., 0.5000)) * stepFactor;\nvec2 pos = vec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.0000);\nfloat weight = 1.0;\nfloat bnoz = randFibo(st) * 0.5000;\nfloat distanceInfo = 0.0;\nvec2 marchPos = st;for (float i = 0.0; i < MAX_ITERATIONS; i += 4.0) {\nfor (float j = 0.0; j < 4.0; j++) {\nfloat bno = randFibo(st + vec2(i/MAX_ITERATIONS + j/4.0)) * 0.5000;\nvec2 offbno = vec2(cos(bno) - 0.5, sin(bno) - 0.5);\nfloat x = min(0.999, (i + j) * offset) + bnoz * 0.02;\nfloat y = min(0.999, (i + j));\nmarchPos = st * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + offbno * 0.02 * 0.2500 * x;\ncolor += texture(uTexture, marchPos).rgb * weight;\ndistanceInfo += y * weight;\nweight *= decay;\nif(weight < 0.01) break;\n}\n}\nreturn vec4(color / MAX_ITERATIONS, distance(st, marchPos));\n}vec4 getGodRays(vec2 uv) {\nif(0.0100 == 0.) {\nreturn vec4(0);\n}\nvec4 rays = godRays(uv, 0.972);\nrays.rgb *= vec3(1, 1, 1);\nvec4 color;\ncolor.rgb = rays.rgb;\ncolor.a = rays.a;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn getGodRays(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(1 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform sampler2D uBlueNoise;uniform vec2 uResolution;const float MAX_ITERATIONS = 64.;\nconst float PI2 = 6.28318530718;\nconst float EPSILON = 0.0001;\nconst float stepFactor = 0.0098;float luma(vec4 color) {\nreturn dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}float getBlueNoiseOffset(vec2 st) {\nivec2 texSize = ivec2(512, 512);\nvec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0);\nreturn mod((blueNoise.r - 0.5) * PI2, PI2);\n}vec4 composite(vec2 uv) {\nvec4 godrays = texture(uTexture, uv);\nfloat distanceInfo = godrays.a;\nfloat luminance = luma(godrays);\nfloat blueNoise = getBlueNoiseOffset(uv) - 0.5;\nvec2 circNoise = vec2(cos(blueNoise), sin(blueNoise));\nfloat brightnessScale = (1. - (luminance + 0.25));\nvec2 offset = circNoise * 0.05 * pow(brightnessScale, 3.) * distanceInfo * 2.;\nvec4 color = texture(uTexture, uv + offset);\nvec4 bg = texture(uBgTexture, uv);color.rgb = bg.rgb + (color.rgb * 2.9 * 0.0100 + blueNoise * 0.001);\ncolor.a = bg.a + color.r;\nreturn color;\n}vec4 getColor(vec2 uv) {\nreturn composite(uv);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nif(2 == 2) {\nfragColor = color;} else {\nfragColor = color;\n}\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect5"}],"options":{"name":"Genesis (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.5.2","id":"g0wddycntABDVyknsR8P"}